/* $Id: asm_lexer.l,v 1.54 2024/08/28 21:25:00 leavens Exp $ */
/* Scanner for the SSM Assembly Language */

%option header-file = "asm_lexer.h"
%option outfile = "asm_lexer.c"
%option yylineno
%option bison-bridge

%{
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include "ast.h"
#include "parser_types.h"
#include "utilities.h"
#include "char_utilities.h"
#include "lexer.h"

 /* Tokens generated by Bison */
#include "asm.tab.h"

 /* need declaration of fileno, part of the C standard library.
   (Putting an extern declaration here shuts off a gcc warning.) */
extern int fileno(FILE *stream);

/* The filename of the file being read */
char *filename;

/* Have any errors been noted? */
bool errors_noted;

/* The value of a token */
extern YYSTYPE yylval;

/* The FILE used by the generated lexer */
extern FILE *yyin;

#undef yywrap   /* sometimes a macro by default */

// apparently strdup is not declared in <string.h>
extern char *strdup(const char *s);

// set the lexer's value for a token in yylval as an AST
static void tok2ast(int toknum) {
    AST t;
    t.token.file_loc = file_location_make(filename, yylineno);
    t.token.type_tag = token_ast;
    t.token.toknum = toknum;
    t.token.text = strdup(yytext);
    yylval = t;
}

static void reg2ast(const char *txt) {
    AST t;
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.type_tag = reg_ast;
    t.reg.text = strdup(yytext);
    reg_num_type n;
    sscanf(txt, "%hu", &n);
    t.reg.number = n;
    yylval = t;
}

static void namedreg2ast(unsigned short num, const char *txt) {
    AST t;
    t.reg.file_loc = file_location_make(filename, yylineno);
    t.reg.type_tag = reg_ast;
    t.reg.text = strdup(yytext);
    t.reg.number = num;
    yylval = t;
}


static void ident2ast(const char *name) {
    AST t;
    t.ident.file_loc = file_location_make(filename, yylineno);
    t.ident.type_tag = ident_ast;
    t.ident.name = strdup(name);
    yylval = t;
}

static void unsignednum2ast(unsigned short val)
{
    AST t;
    t.unsignednum.file_loc = file_location_make(filename, yylineno);
    t.unsignednum.type_tag = unsignednum_ast;
    t.unsignednum.text = strdup(yytext);
    t.unsignednum.value = val;
    yylval = t;
}

static void charliteral2ast()
{
    AST t;
    int charlit_len;  // number of characters in the literal
    t.charlit.file_loc = file_location_make(filename, yylineno);
    assert(t.charlit.file_loc != NULL);
    t.charlit.type_tag = char_literal_ast;
    const char *start_of_literal = yytext+1;
    t.charlit.value = char_utilities_char_value(start_of_literal,
						&charlit_len);
    yylval = t;
}

#define STRINGLITERALMAXSIZE 1024

static void stringliteral2ast()
{
    AST t;
    t.stringlit.file_loc = file_location_make(filename, yylineno);
    assert(t.stringlit.file_loc != NULL);
    t.stringlit.type_tag = string_literal_ast;
    int len = strlen(yytext);
    if (len < 2) {
        bail_with_error("String literal is too short in stringLiteral2ast!");
    }
    assert(len >= 2);
    // take off length for the quotation marks,
    len = len - 2;

    char strval[STRINGLITERALMAXSIZE];
    int ri = 0; // result index (into strval)
    int yi = 1; // index into yytext
    int charlit_len = 0; // length read for a char literal
    while (yi <= len && yytext[yi] != '\"' && ri < (STRINGLITERALMAXSIZE-1)) {
	strval[ri] = char_utilities_char_value(yytext+yi, &charlit_len);
        ri++;
	yi = yi+charlit_len;
    }
    if (ri >= STRINGLITERALMAXSIZE) {
        bail_with_prog_error(*(t.stringlit.file_loc),
			     "String literal is too long (missing double quote?)");
    }
    strval[ri] = '\0';
    assert(ri == strlen(strval));
    t.stringlit.pointer = strdup(strval);
    yylval = t;
}

%}

 /* you can add actual definitions below */

DECDIGIT	[0-9]
OCTDIGIT        [0-7]
HEXDIGIT        [0-9A-Fa-f]
UNSIGNEDNUMBER  (((0x){HEXDIGIT}+)|{DECDIGIT}+)
LETTER		[_a-zA-Z]
LETTERORDIGIT	({LETTER}|{DECDIGIT})
IDENT		{LETTER}({LETTERORDIGIT}*)
NEWLINE         \n
CR              \r
EOL             ({NEWLINE}|({CR}{NEWLINE}))
COMMENTSTART    #
COMMENT         {COMMENTSTART}.*
IGNORED         [ \t\v\f\r]
BACKSLASH       \\
CHARAFTERBACKSLASH  ([nrftvab'\"\\]|x{HEXDIGIT}+|0{OCTDIGIT}*)
CHARESCAPE      {BACKSLASH}{CHARAFTERBACKSLASH}
                /* char codes for char-literals */
CHARCODE        ({CHARESCAPE}|[^\'\\\n])
                /* string chars for string-literals */
STRINGCHAR      ({CHARESCAPE}|[^\"\\\n])

  /* states of the lexer */

%s INSTRUCTION
%s DATADECL

%%

{IGNORED}       { ; } /* do nothing */
{COMMENT}       { ; } /* ignore comments */
<INSTRUCTION>{EOL} { BEGIN INITIAL; return eolsym; }
<DATADECL>{EOL} { BEGIN INITIAL; return eolsym; }
{EOL}           { ; } /* ignore EOL outside of the above states */

NOP             { BEGIN INSTRUCTION; tok2ast(noopsym); return noopsym; }
ADD             { BEGIN INSTRUCTION; tok2ast(addopsym); return addopsym; }
SUB             { BEGIN INSTRUCTION; tok2ast(subopsym); return subopsym; }
CPW             { BEGIN INSTRUCTION; tok2ast(cpwopsym); return cpwopsym; }
AND             { BEGIN INSTRUCTION; tok2ast(andopsym); return andopsym; }
BOR             { BEGIN INSTRUCTION; tok2ast(boropsym); return boropsym; }
NOR             { BEGIN INSTRUCTION; tok2ast(noropsym); return noropsym; }
XOR             { BEGIN INSTRUCTION; tok2ast(xoropsym); return xoropsym; }
LWR             { BEGIN INSTRUCTION; tok2ast(lwropsym); return lwropsym; }
SWR             { BEGIN INSTRUCTION; tok2ast(swropsym); return swropsym; }
SCA             { BEGIN INSTRUCTION; tok2ast(scaopsym); return scaopsym; }
LWI             { BEGIN INSTRUCTION; tok2ast(lwiopsym); return lwiopsym; }
NEG             { BEGIN INSTRUCTION; tok2ast(negopsym); return negopsym; }
LIT             { BEGIN INSTRUCTION; tok2ast(litopsym); return litopsym; }
ARI             { BEGIN INSTRUCTION; tok2ast(ariopsym); return ariopsym; }
SRI             { BEGIN INSTRUCTION; tok2ast(sriopsym); return sriopsym; }
MUL             { BEGIN INSTRUCTION; tok2ast(mulopsym); return mulopsym; }
DIV             { BEGIN INSTRUCTION; tok2ast(divopsym); return divopsym; }
CFHI            { BEGIN INSTRUCTION; tok2ast(cfhiopsym); return cfhiopsym; }
CFLO            { BEGIN INSTRUCTION; tok2ast(cfloopsym); return cfloopsym; }
SLL             { BEGIN INSTRUCTION; tok2ast(sllopsym); return sllopsym; }
SRL             { BEGIN INSTRUCTION; tok2ast(srlopsym); return srlopsym; }
JMP             { BEGIN INSTRUCTION; tok2ast(jmpopsym); return jmpopsym; }
CSI             { BEGIN INSTRUCTION; tok2ast(csiopsym); return csiopsym; }
JREL            { BEGIN INSTRUCTION; tok2ast(jrelopsym); return jrelopsym; }
ADDI            { BEGIN INSTRUCTION; tok2ast(addiopsym); return addiopsym; }
ANDI            { BEGIN INSTRUCTION; tok2ast(andiopsym); return andiopsym; }
BORI            { BEGIN INSTRUCTION; tok2ast(boriopsym); return boriopsym; }
NORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return noriopsym; }
XORI            { BEGIN INSTRUCTION; tok2ast(xoriopsym); return xoriopsym; }
BEQ             { BEGIN INSTRUCTION; tok2ast(beqopsym); return beqopsym; }
BGEZ            { BEGIN INSTRUCTION; tok2ast(bgezopsym); return bgezopsym; }
BGTZ            { BEGIN INSTRUCTION; tok2ast(bgtzopsym); return bgtzopsym; }
BLEZ            { BEGIN INSTRUCTION; tok2ast(blezopsym); return blezopsym; }
BLTZ            { BEGIN INSTRUCTION; tok2ast(bltzopsym); return bltzopsym; }
BNE             { BEGIN INSTRUCTION; tok2ast(bneopsym); return bneopsym; }
JMPA            { BEGIN INSTRUCTION; tok2ast(jmpaopsym); return jmpaopsym; }
CALL            { BEGIN INSTRUCTION; tok2ast(callopsym); return callopsym; }
RTN             { BEGIN INSTRUCTION; tok2ast(rtnopsym); return rtnopsym; }
EXIT            { BEGIN INSTRUCTION; tok2ast(exitopsym); return exitopsym; }
PSTR            { BEGIN INSTRUCTION; tok2ast(pstropsym); return pstropsym; }
PCH             { BEGIN INSTRUCTION; tok2ast(pchopsym); return pchopsym; }
RCH             { BEGIN INSTRUCTION; tok2ast(rchopsym); return rchopsym; }
STRA            { BEGIN INSTRUCTION; tok2ast(straopsym); return straopsym; }
NOTR            { BEGIN INSTRUCTION; tok2ast(notropsym); return notropsym; }

WORD            { BEGIN DATADECL; tok2ast(wordsym); return wordsym; }
CHAR            { BEGIN DATADECL; tok2ast(charsym); return charsym; }
STRING          { BEGIN DATADECL; tok2ast(stringsym); return stringsym; }

\+              { tok2ast(plussym); return plussym; }
-               { tok2ast(minussym); return minussym; }
,               { return commasym; }

\.text          { tok2ast(dottextsym); return dottextsym; }
\.data          { tok2ast(dotdatasym); return dotdatasym; }
\.stack         { tok2ast(dotstacksym); return dotstacksym; }
\.end           { return dotendsym; }
\=              { tok2ast(equalsym); return equalsym; }
:               { return colonsym; }
\[              { tok2ast(lbracketsym); return lbracketsym; }
\]              { tok2ast(rbracketsym); return rbracketsym; }

'{CHARCODE}'    { charliteral2ast(); return charliteralsym; }
\"{STRINGCHAR}*\"  { stringliteral2ast(); return stringliteralsym; }

{UNSIGNEDNUMBER} { unsigned short val;
                  int ssf_ret;
                  size_t len = strlen(yytext);
                  if (yyleng >= 2 && (strncmp(yytext, "0x", 2) == 0)) {
                      // hex literal
                      if (len > 6) {
                          bail_with_error(
                             "Unsigned literal has too many digits \"%s\"", 
                             yytext);
                      }
                      ssf_ret = sscanf(yytext+2, "%hx", &val);
                      if (ssf_ret != 1) {
                         bail_with_error("Unsigned hex literal (%s) could not be read by lexer!",
                         yytext);
                      }
                  } else {
                      if (len > 5) {
                         bail_with_error(
                            "Unsigned decimal literal has too many digits \"%s\"", 
                            yytext);
                      }
                      ssf_ret = sscanf(yytext, "%hu", &val);
                      if (ssf_ret != 1) {
                         bail_with_error("Unsigned decimal literal (%s) could not be read by lexer!",
                         yytext);
                      }
                  }
                  unsignednum2ast(val);
                  return unsignednumsym; 
                }

${OCTDIGIT}     { reg2ast(yytext+1); return regsym; }
${UNSIGNEDNUMBER} { char msgbuf[512];
                    sprintf(msgbuf, "Register numbers must be between 0 and 7 (inclusive, (not like \"%s\")", 
                            yytext);
                    yyerror(lexer_filename(), msgbuf);
                  }
$gp             { namedreg2ast(0,yytext); return regsym; }
$sp             { namedreg2ast(1,yytext); return regsym; }
$fp             { namedreg2ast(2,yytext); return regsym; }
$r3             { namedreg2ast(3,yytext); return regsym; }
$r4             { namedreg2ast(4,yytext); return regsym; }
$r5             { namedreg2ast(5,yytext); return regsym; }
$r6             { namedreg2ast(6,yytext); return regsym; }
$ra             { namedreg2ast(7,yytext); return regsym; }
{IDENT}         { ident2ast(yytext); return identsym; }


.   { char msgbuf[512];
      sprintf(msgbuf, "invalid character: '%c' ('\\0%o')", *yytext, *yytext);
      yyerror(lexer_filename(), msgbuf);
    }
%%

/* Requires: fname != NULL
 * Requires: fname is the name of a readable file
 * Initialize the lexer and start it reading from the given file. */
void lexer_init(char *fname) {
   errors_noted = false;
   filename = fname;    
   yyin = fopen(fname, "r");
   if (yyin == NULL) {
       bail_with_error("Lexer cannot open %s", fname);
   }
}

// Close the file yyin
// and return 0 to indicate that there are no more files
int yywrap() {
    if (yyin != NULL) {
	int rc = fclose(yyin);
	if (rc == EOF) {
	    bail_with_error("Cannot close %s!", filename);
	}
    }
    filename = NULL;
    return 1;  /* no more input */
}

// Return the name of the current input file
const char *lexer_filename() {
    return filename;
}

// Return the line number of the next token
unsigned int lexer_line() {
    return yylineno;
}

/* Report an error to the user on stderr */
void yyerror(const char *filename, const char *msg)
{
    fflush(stdout);
    fprintf(stderr, "%s:%d: %s\n", filename, lexer_line(), msg);
    errors_noted = true;
}

// On standard output:
// Print a message about the file name of the lexer's input
// and then print a heading for the lexer's output.
void lexer_print_output_header()
{
    printf("Tokens from file %s\n", lexer_filename());
    printf("%-6s %-4s  %s\n", "Number", "Line", "Text");
}

// Print information about the token t to stdout
// followed by a newline
void lexer_print_token(enum yytokentype t, unsigned int tline,
		       const char *txt)
{
    printf("%-6d %-4d \"%s\"\n", t, tline, txt);
}

/* Read all the tokens from the input file
 * and print each token on standard output
 * using the format in lexer_print_token */
void lexer_output()
{
    lexer_print_output_header();
    AST dummy;
    yytoken_kind_t t;
    do {
	t = yylex(&dummy);
	if (t == YYEOF) {
	    break;
	}
        if (t != eolsym) {
	    lexer_print_token(t, yylineno, yytext);
        } else {
	    lexer_print_token(t, yylineno, "\\n");
	}
    } while (t != YYEOF);
}
